
<div align="center">
    <h1>FastAPI: Fundamentos, Path Operations y Validaciones</h1>

</div>

- [Fundamentos de FastAPI](#fundamentos-de-fastapi)
  - [¬øQu√© es FastAPI?](#qu√©-es-fastapi)
  - [Frameworks que utiliza FastAPI por detr√°s](#frameworks-que-utiliza-fastapi-por-detr√°s)
  - [Hello World!](#hello-world)
  - [Documentaci√≥n interactiva de una API](#documentaci√≥n-interactiva-de-una-api)
- [Desarmando el framework](#desarmando-el-framework)
  - [Path Operations](#path-operations)
    - [Partes del protocolo HTTP](#partes-del-protocolo-http)
    - [Operations (M√©todos)](#operations-m√©todos)
  - [Path Parameters](#path-parameters)
  - [Query Parameters](#query-parameters)
  - [Request Body y Response Body](#request-body-y-response-body)
  - [Models](#models)
- [Validaciones](#validaciones)
  - [Validaciones: Query Parameters](#validaciones-query-parameters)
  - [Validaciones: explorando m√°s parameters](#validaciones-explorando-m√°s-parameters)
  - [Validaciones: Path Parameters](#validaciones-path-parameters)
  - [Validaciones: Request Body](#validaciones-request-body)
  - [Validaciones: Models](#validaciones-models)
  - [Tipos de datos especiales](#tipos-de-datos-especiales)


## ¬øQu√© es FastAPI?

[FastAPI](https://fastapi.tiangolo.com/) es el framework mas veloz para el desarrollo web con Python. Enfocado para realizar APIs, es el mas r√°pido en lo que respecta a la velocidad del servidor compitiendo directamente con Node.Js o GO, considerados los lenguajes mas veloces para desarrollo de backend. 

Fue creado por [Sebastian Ramirez](https://twitter.com/tiangolo), es de c√≥digo abierto y se encuentra en Github. Es usado por empresas como Uber, Windows, Netflix y Office.

## Frameworks que utiliza FastAPI por detr√°s

> FastAPI es framework que est√° parado, sobre los hombros de gigantes.

Los frameworks que utiliza son:

![frameworks-que-usa-fast-api-por-detras](./imgs/packages.png)

- [Uvicorn](https://www.uvicorn.org/): es una librer√≠a de Python que funciona de servidor, es decir, permite que cualquier computadora se convierta en un servidor.
  - Un servidor puede ser:
    - Una computadora que distribuye tu aplicaci√≥n.
    - Un paquete que convierta a tu computadora en esa computadora que distribuya tu aplicaci√≥n.

- [Starlette](https://www.starlette.io/): es un framework de desarrollo web de bajo nivel, para desarrollar aplicaciones donde se requiere un amplio conocimiento de Python. FastAPI lo toma como base y se encarga de a√±adirle funcionalidades por encima para que se pueda usar mas f√°cilmente.

- [Pydantic](https://pydantic-docs.helpmanual.io/): Es un framework que permite trabajar con datos similar a pandas, pero este te permite usar modelos los cuales aprovechara FastAPI para crear la API.

## Hello World!

1. Creamos un entorno virtual para trabajar sobre el. (Hay documentacion, no lo explicar√©)
2. Activamos entorno e instalamos fastapi:
   - Debemos instalar uvicorn tambien porque no se instala como dependencia de fastapi: `pip install fastapi uvicorn`
3. Creamos archivo main.py y creamos el hola mundo:

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def home():
    return {"Hello": "World"}
```

4. Uniciamos nuestro servidor desde una terminal con el comando: `uvicorn main:app --reload`
   - `uvicorn`: framework que crea el servidor.
   - `main:app`: Archivo que contiene nuestra app
   - `--reload`: Para que actualice el servidor automaticamente
5. Vamos a nuestro navegador y abrimos nuestro servidor en **127.0.0.1:8000**

## Documentaci√≥n interactiva de una API

FastAPI tambi√©n parado sobre los hombros de OpenAPI para generar documentaci√≥n.

- [Open APIs](https://www.openapis.org/): es una especificaci√≥n que define como describir, crear y visualzar API‚Äôs. Permite reconocer si una API est√° definida adecuadamente. Require de Swagger.

- [Swagger](https://swagger.io/): Es un framework para trabajar API‚Äôs.
- [ReDoc](https://redocly.com/) es un framework alternativo a Swagger, instalado por default con FastAPI.

FastAPI funciona sobre SwaggerUI (User Interface) que permite mostrar graficamente la API documentada. SwaggerUI obtiene especificaciones de Open API y la muestra por Fast API.

Swagger UI: http://127.0.0.1:8000/docs

![swagger-docs](./imgs/docs.png)

ReDoc UI: http://127.0.0.1:8000/redoc

![redoc ui](./imgs/redoc.png)


## Path Operations

**Path Operation: Es la combinaci√≥n de una ruta acompa√±ada de un m√©todo.**

Est√° dividido en dos partes:

- **Path/Routes/Endpoints**: Se le llama as√≠ a todos los elemento que agregamos a la derecha del dominio. (Tambien llamados endpoints)

- **Operations**: Es exactamente lo mismo que un m√©todo HTTP.

```python
@app.get("/") # Path Operator DECORATOR
def home(): # Path Operator FUNCTION
    return {"Hello": "World"}
```

![path-operations](./imgs/path-operations.png)

#### Partes del protocolo HTTP

- **Headers**: Son esquemas de `key: value` que contienen informaci√≥n sobre el HTTP request y el navegador. Aqu√≠ tambi√©n se encuentran los datos de las cookies. La mayor√≠a de los headers son opcionales.Como los headers HTTP son una parte fundamental de los mensajes entre clientes y servidores, el siguiente recurso puede ser util: [Headers del protocolo HTTP](https://diego.com.es/headers-del-protocolo-http)
- **Body**: Si se env√≠a informaci√≥n al servidor a trav√©s de POST o PUT, esta va en el body.
- **Method**: Son operaciones que se pueden realizar mediante el protocolo.

#### Operations (M√©todos)

[M√©todos de petici√≥n HTTP by Mozilla](https://developer.mozilla.org/es/docs/Web/HTTP/Methods)

Los siguientes m√©todos son los mas utilizados:

- `GET`: El m√©todo `GET` solicita una representaci√≥n de un recurso espec√≠fico. Las peticiones que usan el m√©todo `GET` s√≥lo deben recuperar datos.
- `POST`: El m√©todo `POST` se utiliza para enviar una entidad a un recurso en espec√≠fico, causando a menudo un cambio en el estado o efectos secundarios en el servidor.
- `PUT`: El modo `PUT` reemplaza todas las representaciones actuales del recurso de destino con la carga √∫til de la petici√≥n.
- `DELETE`: El m√©todo `DELETE` borra un recurso en espec√≠fico.

Los siguientes m√©todos son menos utilizados y mas complejos:

- `OPTIONS`: El m√©todo `OPTIONS` es empleado para describir las opciones de comunicaci√≥n para el recurso de destino.
- `HEAD`: El m√©todo `HEAD` pide una respuesta id√©ntica a la de una petici√≥n GET, pero sin el cuerpo de la respuesta.
- `PATCH`: Para editar partes concretas de un recurso.
- `TRACE`: El m√©todo `TRACE` realiza una prueba de bucle de retorno de mensaje a lo largo de la ruta al recurso de destino.
- `CONNECT`: El m√©todo `CONNECT` establece un t√∫nel hacia el servidor identificado por el recurso.

## Path Parameters

Imaginemos que tenemos un endpoint para una acci√≥n particular. En el ejemplo analicemos twitter.

Por endpoint queremos mostrar un tweet, aqui nuestros endpoints:

```text
- "/" -> Home
- "/tweets/22"
- "/tweets/1"
- "/tweets/2"
```

- ¬øQu√© pasa si la el n√∫mero de tweets crece de una forma que no te permita utilizar la estrucutura de los endpoints que habiamos trabajado?
- ¬øEs viable crear un endpoint para cada tweet que se escribe?

Para esto tenemos los **Path Parameters**:

Un Path parameter es una variable definida dentro de un Path, que nos permite manejar un valor de manera dinamica.

La definici√≥n de un Path Parameter nos **OBLIGA** a pasar la variable siempre en el endpoint.

```
#Sintaxis de un Path Parameter üëá
/tweets/"{tweet_id}" -> Particular tweet
```

## Query Parameters

Si los Path Parameters son obligatorios, necesitamos alguna forma de tener parametros que no sean obligatorios, bueno, estos son los Query Parameters.

Los Query Parameters son Par√°metros opcionales para nuestros Endpoints. Usos:

- Para de aplicar b√∫squedas o filtros del recurso que le devolveremos a los usuarios de nuestra API.

Para indicar que comenzaremos a agregar un query parameter usamos el s√≠mbolo de **interrogaci√≥n** `?` seguido del nombre del campo con el valor a aplicar.

Si necesitas mandar m√°s de un par√°metro opcional, lo √∫nico que hay que hacer es concatenar con el s√≠mbolo de **ampersan** `&` y agregar m√°s par√°metros.

![query-parameter](./imgs/query-parameters.png)

Ejemplo de uso:

```

http://127.0.0.1:8000/items/?skip=0&limit=10
/users/{user_id}/details/?age=20&height=184
```


## Request Body y Response Body

Debes saber que bajo el protocolo HTTP existe una comunicaci√≥n entre el usuario y el servidor. Esta comunicaci√≥n est√° compuesta por cabeceras (headers) y un cuerpo (body). Por lo mismo, se tienen dos direcciones en la comunicaci√≥n entre el cliente y el servidor y definen de la siguiente manera:

- Request : Cuando el cliente solicita/pide datos al servidor.
- Response : Cuando el servidor responde al cliente.
- Request Body : Request Body viene a ser el cuerpo (body) de una solicitud del cliente al servidor.
- Response Body : viene a ser el cuerpo (body) de una respuesta del servidor al cliente.

![request-body](./imgs/request_body.png)


## Models

Un modelo es la representacion de una entidad en codigo, al menos de una manera descriptiva.

¬øComo luce un modelo dentro de FastAPI?

Modelo pydantic para validar datos:

~~~python
from typing import Optional
from pydantic import BaseModel
from fastapi import FastAPI
from fastapi import Body

app = FastAPI()


class Person(BaseModel):
    first_name: str
    last_name: str
    age: int
    hair_color: Optional[str] = None
    is_married: Optional[bool] = None


@app.get("/")
def home():
    return {"Hello": "World"}


# Request and Response
@app.post("/person/new")
def create_person(person: Person = Body(...)):
    return person

~~~


Documentacion Oficial: https://fastapi.tiangolo.com/tutorial/sql-databases/

## Validaciones: Query Parameters

Para especificar las validaciones, debemos pasarle como par√°metros a la funci√≥n Query lo que necesitemos validar.



~~~python
rom typing import Optional

from fastapi import FastAPI
from fastapi import Query

app = FastApi()

@app.get('/person/detail')
def show_person(
    name: Optional[str] = Query(
        default=None,
        min_length=1,
        max_length=50
    ),

    # El ... para hacerlo obligatorio, no recomendado en un Query parameter
    age: int = Query(...)
):
    '''
    Funcion para probar la validacion en los query parameter.
    El Age esta obligatorio, no se recomienda hacer esto, si necesitas un
    parametro obligatorio se recomienda hacerlo en un path parameter
    '''
    return {name: age}
~~~

## Validaciones: explorando m√°s parameters

Para tipos de datos str:

- max_length : Para especificar el tama√±o m√°ximo de la cadena.
- min_length : Para especificar el tama√±o minimo de la cadena.
- regex : Para especificar expresiones regulares.

Para tipos de datos int:

- ge : (greater or equal than ‚â•) Para especificar que el valor debe ser mayor o igual.
- le : (less or equal than ‚â§) Para especificar que el valor debe ser menor o igual.
- gt : (greater than >) Para especificar que el valor debe ser mayor.
- lt : (less than <) Para especificar que el valor debe ser menor.

## Validaciones: Path Parameters

~~~python

from typing import Optional
from pydantic import BaseModel
from fastapi import FastAPI, Path, Query
from fastapi import Body

app = FastAPI()


class Person(BaseModel):
    first_name: str
    last_name: str
    age: int
    hair_color: Optional[str] = None
    is_married: Optional[bool] = None


@app.get("/")
def home():
    return {"Hello": "World"}


# Request and Response
@app.post("/person/new")
def create_person(person: Person = Body(...)):
    return person

# Validaciones: query parameters


@app.get("/person/detail")
def show_person(
    name: Optional[str] = Query(
        default=None,
        min_length=1,
        max_length=50,
        title="PErson Name",
        description="This is the person name. It's between 1 and 50 characters long"),
    age: int = Query(
        ...,
        title="Person Age",
        description="This is the person age. It's required",)
):
    return {"name": name, "age": age}

# Validaciones: path parameters


@app.get("/person/detail/{person_id}")
def show_person(
    person_id: int = Path(
        ...,
        title="The ID of the person to get",
        ge=0,
        le=100)
):
    return {"person_id": person_id}

~~~

## Validaciones: Request Body

~~~python 
#Pydantic
from pydantic import BaseModel

#FastAPI
from fastapi import FastAPI
from fastapi import Path

app = FastAPI()


# Validaciones: Request Body

@app.put("/person/{person_id}")
def update_person(
    person_id: int = Path(
        ...,
        title="Person ID",
        description="This is the person ID",
        gt=0
    ),
    person: Person = Body(...),
    location: Location = Body(...)
): 
    results = person.dict()
    results.update(location.dict())
    return results
# OR
		return {
        'person': person,
        'location': location
    }
~~~

### Diferencia Path, Query Parameters and Request Body

usamos **Path Parameters** cuando por ejemplo se trata de un id y esas cosas, como una variable etc, usamos los **Requests Body** para enviar informaci√≥n que tiene formato de un modelo y usamos los **Query Parameters** para solicitar infomaci√≥n opcional del servidor.

## Validaciones: Models

Para validar modelos tomamos uso de la clase de Pydantic Field, que funciona igual a las validaciones que ya hemos hecho con Path, Query y Body

```python
from pydantic import BaseModel, Field

class Person(BaseModel):
    first_name: str = Field(
        ...,
        min_length=1,
        max_length=50,
    )
    last_name: str = Field(
        ...,
        min_length=1,
        max_length=50,
    )
    age: int = Field(
        ...,
        gt=0,
        le=110
    )
    hair_color: Optional[HairColor] = Field(default=None)
    is_married: Optional[bool] = Field(default=None)
```

Puedes ver que en hair_color ya tenemos un tipo distinto a String esto lo hacemos para validar que tenga un campo permitido, haciendo otra clase usando Enum

```python
from enum import Enum

class HairColor(Enum):
    white: str = 'white'
    black: str = 'black'
    brown: str = 'brown'
    red: str = 'red'
    blonde: str = 'blonde'
    tinted: str = 'tinted'
```

Aqu√≠ tenemos enumerados algunos colores de pelo y ahora cada vez que alguien trate de ingresar un valor que no se encuentra en nuestra clase que hereda de Enum, le arrojar√° un error 422 Unprocessable Entity con el siguiente mensaje

## Tipos de datos especiales

### Cl√°sicos

- str ‚Üí Texto
- int ‚Üí Enteros
- float ‚Üí decimales
- bool ‚Üí Booleanos

### Ex√≥ticos

- Enum ‚Üí Valores que se encuentren en una lista enumerada
- HttpUrl ‚Üí un URL con los siguentes argumentos -¬†`strip_whitespace: bool = True`¬†-¬†`min_length: int = 1`¬†-¬†`max_length: int = 2 ** 16`¬†-¬†`tld_required: bool = True`¬†-¬†`allowed_schemes: Optional[Set[str]] = None`  , por ejemplo [https://example.com](http://example.com) o www.example.com
- FilePath ‚Üí ruta absoluta a un archivo, ej: C:\Users\58412\Downloads\example.pdf
- DirectoryPath ‚Üí ruta absoluta a un directorio, ej: C:\Users\58412\Downloads
- EmailStr ‚Üí un correo electr√≥nico, ej: example@gmail.com
- PaymentCardNumber ‚Üí valida pagos por tarjetas de cr√©dito o d√©bito
- IPvAnyAddress ‚Üí validar si nos ingresan una direcci√≥n IP
- NegativeFloat ‚Üí valida si nos ingresa un flotante negativo
- PositiveFloat ‚Üí  valida si nos ingresa un flotante positivo
- NegativeInt ‚Üí valida si nos ingresa un entero negativo
- PositiveInt ‚Üí valida si nos ingresa un entero positivo

Mas en la documentaci√≥n: 
https://pydantic-docs.helpmanual.io/usage/types/#pydantic-types


## Creando ejemplos de Request Body autom√°ticos

si se quiere agregar datos por defecto en la documentaci√≥n entonces se puede usar lo siguiente:

* una clase con el nombre "Config" dentro de la clase que define el tipo

~~~python
class Person(BaseModel):
    first_name: str = Field(..., min_length=1, max_length=50)
    last_name: str = Field(..., min_length=1, max_length=50)
    age: int = Field(..., gt=0, lt=115)
    hair_color: Optional[HairColor] = Field(default=None)
    is_married: Optional[bool] = Field(default=None)

    class Config:
        schema_extra = {
            "example": {
                "first_name": "John",
                "last_name": "Doe",
                "age": 30,
                "hair_color": "brown",
                "is_married": True
            }
        }
~~~

- tambien se puede definir un valor por defecto como parametro

~~~python
class Person(BaseModel):
    first_name: str = Field(..., example="joel", min_length=1, max_length=50)
    last_name: str = Field(..., example="barrantes",
                           min_length=1, max_length=50)
    age: int = Field(..., example=25, gt=0, lt=115)
    hair_color: Optional[HairColor] = Field(
        default=None, example=HairColor.brown)
    is_married: Optional[bool] = Field(default=None, example=False)
~~~

## Creando ejemplos de Path y Query parameters autom√°ticos

~~~python
# Validaciones: Query Parameters
@app.get('/person/detail')
def show_person(
    name: Optional[str] = Query(
        None,
        min_length=1,
        max_length=50,
        title='Person name',
        description='This is the person name. It is between 1 and 50 characters',
        example='Dulce'
        ),
    age: str = Query(
        ...,
        title='Person age',
        description='This is the person age. It is required',
        example=22
        )
):
    return {name: age}

# Validaciones: Path Parameters
@app.get('/person/detail/{person_id}')
def show_person(
    person_id: int = Path(
        ...,
        gt=0,
        title='Person ID',
        description='This is the person ID. It is required',
        example=30
        )
):
    return {person_id: 'It exists!'}
~~~