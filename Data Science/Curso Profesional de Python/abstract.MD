## Curso Profesional de python

### Python es un **lenguaje interpretado**

lo que significa que tu c√≥digo es transformado por el int√©rprete (m√°quina virtual de Python) a *bytecode* antes de ser ejecutado por un ordenador con *x* sistema operativo. El *bytecode*es un lenguaje de programaci√≥n de m√°s bajo nivel (si esto no te es claro, te recomiendo que vayas a tomar los cursos sobre [lenguajes y paradigmas de programaci√≥n](https://platzi.com/clases/historia-programacion/) y el de [fundamentos de ing. de software](https://platzi.com/clases/ingenieria/).
(B√°sicamente desde que corres tu programa hasta que la PC lo ejecuta
hay una carrera de relevos de lenguajes o protocolos hasta llegar al
transistor y la se√±al el√©ctrica)

### Garbage collector

Recuerda que el *garbage collector*  toma los objetos y variables que no est√°n en uso y los elimina.

### pycache

_pycache _ es el directorio (carpeta) que contiene el *bytecode* (el c√≥digo intermedio) que crea Python para que lo pueda leer la m√°quina virtual.

Un **m√≥dulo** es cualquier archivo de Python. Generalmente, contiene c√≥digo que puedes reutilizar.

#### C√≥mo organizar las carpetas de tus proyectos

<h5>M√≥dulo</h5>
Un m√≥dulo es cualquier archivo de Python (o sea que termina con `.py`). Generalmente, contiene c√≥digo que puedes reutilizar.

<h5>Paquete</h5>
Una carpeta que contiene m√≥dulos. Siempre posee el archivo `__init__.py`. (Se lee dunder init doy py).

| Paquetes |         |
| -------- | ------- |
| M√≥dulo  | M√≥dulo |
| M√≥dulo  | M√≥dulo |
| M√≥dulo  | M√≥dulo |

| exploracion_espacial |                    |
| -------------------- | ------------------ |
| `nave.py`          | `destino.py`     |
| `plataforma.py`    | `lanzamiento.py` |
| `tests.py`         | `validacion.py`  |

Estructura de proyecto:

* README -> Explica c√≥mo funciona el proyecto
* .gitignore -> Cosas que no se subir√°n al repo
* venv -> entorno virtual de Python
* exploracion_espacial -> Paquete, dentro de √©l, los m√≥dulos
  * `__init__.py`
  * `nave.py`
  * `destino.py`
  * `plataforma.py`
  * `lanzamiento.py`
  * `tests.py`
  * `validacion.py`

Esta regla no est√° tallada en piedra. Depende del proyecto y el Framework que uses.

### ¬øQu√© son los tipados?

üíª Los tipados es una clasificaci√≥n de los lenguajes de programaci√≥n, tenemos cuatro tipos:

* Est√°tico
* Din√°mico
* D√©bil
* Fuerte

#### **Est√°tico**

Detectan los errores en tiempo de compilaci√≥n. No se ejecuta hasta corregir. Por ej, *Java*

#### **Din√°mico**

Detectan el error en tiempo de ejecuci√≥n. Nos dice el error cuando llega a la l√≠nea del c√≥digo. Por ej, *Python*

#### **Strong**

M√°s severidad con los tipos de datos. Sumar un n√∫mero + una letra arrojar√° error.

#### **Weak**

Menos severidad con los tipos de datos. Si
quiero sumar n√∫mero y letra, las concatenar√≠a como strings. Castea tipos
de datos autom√°ticamente. Por ej, *PHP, javascript*

### **Tipado est√°tico en Python**

.

Para hacer que Python sea de tipado est√°tico es necesario agregar algo
de sintaxis adicional a lo aprendido, adem√°s, esta caracter√≠stica solo
se puede aplicar a partir de la versi√≥n 3.6.

```python
# De esta manera se declara una variable, se colocan los dos puntos (:), el tipo de dato y para finalizar se usa el signo igual para asignar el valor a la variable.

<variable> : <tipo_de_dato> = <valor_asignado>

a: int = 5
print(a)

b: str = "Hola"
print(b)

c: bool = True
print(c)
```

Del mismo modo se puede usar esta metodolog√≠a de tipado en Python a
funciones adicionando el signo menos a continuaci√≥n del signo mayor que
para determinar el tipo de dato. Ejemplo:

```python
def <nombre_func> ( <parametro1> : <tipo_de_dato>, <parametro2> : <tipo_de_dato> ) ->  <tipo_de_dato> :
	pass

def suma(a: int, b: int) -> int :
	return a + b

print(suma(1,2))

# 3
```

Existe una librer√≠a de fabrica que viene preinstalada con Python que se llama **typing,** que es de gran utilidad para trabajar con tipado con estructuras de datos entre la versi√≥n **3.6** y  **3.9** , entonces:

.

```python
from typing import Dict, List

positives: List [int] = [1,2,3,4,5]

users: Dict [str, int] = {
	"argentina": 1.
	"mexico": 34,
	"colombia": 45,
}

countries: List[Dict[str, str]] = [
	{
		"name" : "Argentina",
		"people" : "45000",
	},
	{
		"name" : "M√©xico",
		"people" : "9000000",
	},
	{
		"name" : "Colombia",
		"people" : "99999999999",
	}
]
```

```python
from typing import Tuple, Dict, List

CoordinatesType = List[Dict[str, Tuple[int, int]]]

coordinates: CoordinatesType = [
	{
		"coord1": (1,2),
		"coord2": (3,5)
	},
	{
		"coord1": (0,1),
		"coord2": (2,5)
	}
]
```

#### Modulo `mypy`

.

El modulo mypy se complementa con el modulo typing ya que permitir√° mostrar los errores de tipado debil en Python.

### **Scope**

El scope es el alcance que tienen las variables. Depende de donde
declares o inicialices una variable para saber si tienes acceso. **Regla de oro:**

> *una variable solo esta disponible dentro de la region donde fue creada*

#### Local Scope

Es la regi√≥n que corresponde el √°mbito de una funci√≥n, donde podremos
tener una o mas variables, las variables van a ser accesibles
√∫nicamente en esta region y no ser√°n visibles para otras regiones

#### Global Scope

Al escribir una o mas variables en esta region, estas podr√°n ser accesibles desde cualquier parte del c√≥digo.

### Closures

#### **Nested functions** :

Las funciones anidadas son
simplemente funciones creadas dentro de otra funci√≥n. Podemos hacer
return de una funci√≥n creada dentro de otra funci√≥n üòµ y luego guardar
esas funciones en variables que podemos utilizar.

```python
def main():
	a = 1
	def nested():
		print(a)
	return nested

my_func = main()
my_func()
# 1
```

* Eso anterior es un closure ü§Ø y es b√°sicamente cuando una variable de
  un scope superior es recordada por una funci√≥n de scope inferior
  (aunque luego se elimine la de scope superior).
  ```python
  def main():
  	a = 1
  	def nested():
  		print(a)
  	return nested

  my_func = main()
  my_func()
  # 1
  del(main)
  my_func()
  # 1
  ```
* Reglas para encontrar un closure: üî•
  * Debemos tener una nested function.
  * La nested function debe referenciar un valor de un scope superior.
  * La funci√≥n que envuelve a la nested function debe retornarla tambi√©n.
* Ejemplo de closures para crear funciones:
  ```python
  def make_multiplier(x):
  	def multiplier(n):
  		return x*n
  	return multiplier

  times10 = make_multiplier(10)
  times4 = make_multiplier(4)

  print(times10(3)) # 30
  print(times4(5)) #20
  print(times10(times4(2))) # 80
  ```
* Los closure aparecen en dos casos particulares: cuando tenemos una
  clase corta (con un solo m√©todo), los usamos para que sean elegantes. El
  segundo caso, es cuando usamos decoradores

### Decoradores

Un **decorador** es una funci√≥n que recibe como
par√°metro otra funci√≥n, le a√±ade cosas y retorna una funci√≥n diferente.
Tienen la misma estructura que los Closures pero en vez de variables lo
que se env√≠a es una funci√≥n. Ejemplo:

```python
def decorador(func):
    def envoltura():
        print("Esto se a√±ade a mi funci√≥n original.")
        func()
    return envoltura

def saludo():
    print("¬°Hola!")

saludo()
# Salida:
# ¬°Hola!

saludo = decorador(saludo) # Se guarda la funci√≥n decorada en la variable saludo
saludo()                   # La funci√≥n saludo est√° ahora decorada
# Salida:
# Esto se a√±ade a mi funci√≥n original.
# ¬°Hola!
```

Se puede hacer de manera mas sencilla, con  *az√∫car sint√°ctica (sugar syntax)* :
Cuando tenemos un c√≥digo que est√° embellecido para que nosotros lo
veamos de una manera m√°s est√°tica, ayudando a entender de manera mas
sencilla el c√≥digo. De esta manera, tenemos el c√≥digo anterior:

```python
def decorador(func):
    def envoltura():
        print("Esto se a√±ade a mi funci√≥n original.")
        func()
    return envoltura

def saludo():
    print("¬°Hola!")
saludo = decorador(saludo) # Se guarda la funci√≥n decorada en la variable saludo (se decora)

saludo()                   # La funci√≥n saludo est√° ahora decorada 
```

```python
def decorador(func):
    def envoltura():
        print("Esto se a√±ade a mi funci√≥n original.")
        func()
    return envoltura

# De esta manera se decora la funci√≥n saludo (equivale a saludo = decorador(saludo) de la √∫ltima l√≠nea, quedando ahora en la l√≠nea inmediata superior ):
@decorador          
def saludo():
    print("¬°Hola!")

saludo()                   # La funci√≥n saludo est√° ahora decorada 
```

Esto permite ahorrar c√≥digo al implementar caracter√≠sticas (decoradores) comunes a diferentes funciones:

```python

def decorator_upper(func):                  # Funci√≥n decoradora
    def wrapper(text):                      # Funci√≥n anidada
        return func(text).upper()           # Operaci√≥n que realiza el decorado a la funci√≥n (func), inserta el texto a la funci√≥n original. Convierte todo a may√∫sculas.
    return wrapper                          # Devuelve wapper como indica la regla de los Clousures

@decorator_upper                            # Decora la funci√≥n message
def message(name):
    return f'{name}, recibiste un mensaje'  # Esto es lo que realiza la funci√≥n message, previo a ser decorada.

@decorator_upper                            # Decora la funci√≥n warning
def warning(name):
    return f'Usa solo may√∫sculas {name}'  # Esto es lo que realiza la funci√≥n warning, previo a ser decorada.

print(message("Cesar")) # Output: CESAR, RECIBISTE UN MENSAJE
print(warning("Cesar")) # Output: USA SOLO MAY√öSCULAS CESAR
```

### Estructuras de datos avanzadas

#### Iteradores

Antes de entender qu√© son los iteradores, primero debemos entender a los iterables.

Son todos aquellos objetos que podemos recorrer en un ciclo. Son
aquellas estructuras de datos divisibles en elementos √∫nicos que yo
puedo recorrer en un ciclo.

Pero en Python las cosas no son as√≠. Los iterables se convierten en iteradores.

Ejemplo:

```python
# Creando un iterador

my_list = [1,2,3,4,5]
my_iter = iter(my_list)

# Iterando un iterador

print(next(my_iter))

# Cuando no quedan datos, la excepci√≥n StopIteration es elevada
```

---

```python
# Creando un iterador

my_list = [1,2,3,4,5]
my_iter = iter(my_list)

# Iterando un iterador

while True: #ciclo infinito
  try:
    element = next(my_iter)
    print(element)
  except StopIteration:
    break
```

**Momento impactante:** El ciclo ‚Äúfor‚Äù dentro de Python, no existe. Es un while con StopIteration.

```python
my_list = [1,2,3,4,5]

for element in my_list:
  print(element)
```

---

`evenNumbers.py`:

```python
class EvenNumbers:
  """Clase que implementa un iterador de todos los n√∫meros pares,
  o los n√∫meros pares hasta un m√°ximo
  """

  #* Constructor de la clase
  def __init__(self, max = None): #self hace referencia al objeto futuro que voy a crear con esta clase
    self.max = max


  # M√©todo para tener elementos o atributos que voy a necesitar para que el iterador funcione
  def __iter__(self):
    self.num = 0 #Primer n√∫mero par
    #* Convertir un iterable en un iterador
    return self

  # M√©todo para tener la funci√≥n "next" de Python
  def __next__(self):
    if not self.max or self.num <= self.max:
      result = self.num
      self.num += 2
      return result
    else:
      raise StopIteration
```

Ventajas de usar iteradores:

1. Nos ahorra recursos.
2. Ocupan poca memoria.



#### Generadores

Sugar syntax de los iteradores. Los generadores son funciones que guardan un estado. Es un iterador escrito de forma m√°s simple.

```python
def my_gen():

  """un ejemplo de generadores"""

  print('Hello world!')
  n = 0
  yield n # es exactamente lo mismo que return pero detiene la funci√≥n, cuando se vuelva a llamar a la funci√≥n, seguir√° desde donde se qued√≥

  print('Hello heaven!')
  n = 1
  yield n

  print('Hello hell!')
  n = 2
  yield n


a = my_gen()
print(next(a)) # Hello world!
print(next(a)) # Hello heaven!
print(next(a)) # Hello hell!
print(next(a)) StopIteration
```

Ahora veremos un **generator expression** (es como list comprehension pero mucho mejor, porque podemos manejar mucha cantidad

de informaci√≥n sin tener problemas de rendimiento):

```python
#Generator expression

my_list = [0,1,4,7,9,10]

my_second_list = [x*2 for x in my_list] #List comprehension
my_second_gen = ()x*2 for x in my_list]) #Generator expression
```



**Sets** :

Los sets son una estructura de datos muy similares a las listas en
cuanto a su forma, pero presentan ciertas caracter√≠sticas particulares:

* Los sets son **inmutables**
* Cada elemento del set es √∫nico, esto es que no se admiten duplicados,
  aun si durante la definici√≥n del set se agregan elementos repetidos
  pyhton solo guarda un elemento
* los sets guardan los elementos en desorden

Para declararlos se utilizan los {} parecido a los diccionarios solo que carece de la composici√≥n de conjunto {a:b, c:d}

```python
# set de enteros
my_set = {1, 3, 5}
print(my_set)

# set de diferentes tipos de datos
my_set = {1.0, "Hi", (1, 4, 7)}
print(my_set)
```

Los sets no pueden ser le√≠dos como las listas o recorridos a trav√©s
de slices, esto debido a que no tienen un criterio de orden. Sin embargo
si podemos agregar o eliminar items de los sets utilizando m√©todos:

* **add():** nos permite agregar elementos al set, si se intenta agregar un elemento existente simplemente python los ignorara
* **update():** nos permite agregar m√∫ltiples elementos al set
* **remove():** permite eliminar un elemento del set, en el caso en que no se encuentre presente dicho elemento, Python elevar√° un error
* **discard():**  permite eliminar un elemento del set,
  en el caso en que no se encuentre presente dicho elemento, Python dejar√°
  el set intacto, sin elevar ning√∫n error.
* **pop():** permite eliminar un elemento del set, pero lo har√° de forma aleatoria.
* **clear():** Limpia completamente el set, dej√°ndolo vaci√≥.

```python
#ejemplo de operaciones sobre sets 
my_set = {1, 2, 3} 
print(my_set) #Output {1, 2, 3} 

#a√±adiendo un elemento al set 
my_set.add(4) 
print(my_set) #Output {1, 2, 3, 4}

#a√±adiendo varios elementos al set, python ignorar√° elementos repetidos 
my_set.update([1, 5, 6]) 
print(my_set) #Output {1, 2, 3, 4, 5, 6}

# eliminado elementos del set 
my_set.discard(1) 
print(my_set) #Output {2, 3, 4, 5, 6}

# borrando un elemento aleatorio 
my_set.pop()
print(my_set) #Output el set menos un elemento aleatorio 

#limpiar el set 
my_set.clear()
print(my_set) # Output set() 
```

Podemos utilizar estructuras de datos existentes para transformarlas a sets utilizando el m√©todo  **set** :

```python
#usando listas para crear sets
my_list = [1, 2, 3, 3, 4, 5]
my_set = set(my_list)
print(my_set)  #output {1, 2, 3, 4, 5}

#usando tuplas para crear sets 
my_tuple: ('hola', 'hola', 1, 2)
my_set2: set(my_tuple)
print(my_set2) #Output {'hola', 1}

```



### Sets

Conjuntos: Una colecci√≥n desordenada de elementos √∫nicos e inmutables.

#### Caracter√≠sticas:

* Un set al ser impreso puede presentar diferente orden al definido
  pues Python los ordena a modo de optimizar/ahorrar memoria: un set es
  una colecci√≥n desordenada.
* En caso de existir elementos repetidos, los elimina, pues: un set es una lista de elementos √∫nicos.
* En caso de indicar una lista, por ejemplo, en un set este nos arroja un error, dado que: un set es inmutable.

Al set no se puede acceder con un √≠ndice.

Para declarar un set, el grupo de elementos debe ir entre llaves. Se
diferencia de los diccionarios ya que no contienen el s√≠mbolo ‚Äú **:** ‚Äù, por lo que autom√°ticamente Python lo entiende como un set de datos.

En caso de desear declarar un set vac√≠o no es posible usar llaves ya
que al no contener datos entre las llaves las interpreta como un
diccionario. En este caso la declaraci√≥n de un set debe ser explicita
mediante el comando **set()**

#### Casting con Sets

Para convertir una estructura de datos a un set se utiliza el comando set()

Si se castea una lista a un set como resultado tenemos un set de
elementos √∫nicos ya que elimina los elementos repetidos. Los elementos
mutables, en caso de existir, este comando los eliminar√°.

#### Agregando elementos a un Set

Para agregar un solo elemento se utiliza el m√©todo **.add** de los sets, en cambio, para agregar m√∫ltiples elementos se utiliza el m√©todo  **.update** . En ambos se eliminan todos los elementos que fuesen repetido en el set o mutables.

#### Eliminando elementos de un Set

Existen 4 m√©todos:

* **.discard()** = Se indica como par√°metro el elemento a
  eliminar, en caso de no exisitir el elemento no realiza ninguna
  operaci√≥n y contin√∫a con la ejecuci√≥n.
* **.remove()** = Tambi√©n se indica como par√°metro el
  elemento a eliminar, pero en este caso si no exististe el elemento
  arroja un error (KeyError) y detiene la ejecuci√≥n.
* **.pop()** = Elimina un elemento del set de manera aleatoria.
* **.clear()** = Limpia el set completo.

#### operadores

**Union** Operator  `|`

**Intersection** Operator `&`

**Difference** Operator `-`

**Symmetric Difference** Operator `^`

```
my_set1 = {1, 2, 3, 4}
my_set2 = {3,4,5,6}
my_set3 = my_set1 | my_set2 ##Union, me uno todos los elementos, y los duplicados no los agrego
print(f"union = {my_set3}")
my_set4 = my_set1 & my_set2 ##Interseccion, me tomo los elementos que esten en ambos sets
print(f"interseccion = {my_set4}")
my_set5 = my_set1 - my_set2 ##Diferencia, me tomo los elementos que esten en el set1 pero no en set2
print(f"diferencia = {my_set5}")
my_set6 = my_set1 ^ my_set2 ##Diferencia simetrica, me tomo los elementos que esten en el set1 o en set2, pero no en ambos
print(f"diferencia simetrica = {my_set6}")
```


```
Esto puede quedar mejor y no tan largo, pero es mejor explicado paso a paso para algunos. Dejo mi aporte. üòÉ

<
def delete_repeated_items(some_list):
    list_converted = set(some_list)
  
    new_list = []

    for element in list_converted:
        new_list.append(element)
  
    return new_list

if __name__ == '__main__':

    the_list = [0, 0, 1, 2, 3, 3, 4, 5, 6, 7, 7]
    print(delete_repeated_items(the_list))
    # return; must be [0, 1, 2, 3, 4, 5, 6, 7]
> 

```





#### Manejo de fechas

`datetime` es un m√≥dulo de manejo de fechas.

```python
import datetime

my_time = datetime.datetime.now() # hora local de mi PC u hora universal
my_date = datetime.date.today() # fecha actual

my_day = datetime.date.today()

print(my_time)
print(my_date)

print(f'Year: {my_day.year}')
print(f'Month: {my_day.month}')
print(f'Day: {my_day.day}')
```

Tabla de c√≥digos de formato para fechas y horas(los m√°s importantes):

| Formato  | C√≥digo |
| -------- | ------- |
| A√±o     | %Y      |
| Mes      | %m      |
| D√≠a     | %d      |
| Hora     | %H      |
| Minutos  | %M      |
| Segundos | %S      |

```python
from datetime import datetime

my_datetime = datetime.now()
print(my_datetime)

latam = my_datetime.strftime('%d/%m/%Y')
print(f'Formato LATAM: {latam}')

usa = my_datetime.strftime('%m/%d/%Y')
print(f'Formato USA: {usa}')

random_format = my_datetime.strftime('a√±o %Y mes %m d√≠a %d')
print(f'Formato random: {random_format}')

formato_utc = datetime.utcnow()
print(f'Formato UTC: {formato_utc}')
```


---

```



```
