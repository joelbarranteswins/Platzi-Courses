## Curso Profesional de python

### Python es un **lenguaje interpretado**

lo que significa que tu c贸digo es transformado por el int茅rprete (m谩quina virtual de Python) a *bytecode* antes de ser ejecutado por un ordenador con *x* sistema operativo. El *bytecode*es un lenguaje de programaci贸n de m谩s bajo nivel (si esto no te es claro, te recomiendo que vayas a tomar los cursos sobre [lenguajes y paradigmas de programaci贸n](https://platzi.com/clases/historia-programacion/) y el de [fundamentos de ing. de software](https://platzi.com/clases/ingenieria/).
(B谩sicamente desde que corres tu programa hasta que la PC lo ejecuta
hay una carrera de relevos de lenguajes o protocolos hasta llegar al
transistor y la se帽al el茅ctrica)

### Garbage collector

Recuerda que el *garbage collector*  toma los objetos y variables que no est谩n en uso y los elimina.

### pycache

_pycache _ es el directorio (carpeta) que contiene el *bytecode* (el c贸digo intermedio) que crea Python para que lo pueda leer la m谩quina virtual.

Un **m贸dulo** es cualquier archivo de Python. Generalmente, contiene c贸digo que puedes reutilizar.

#### C贸mo organizar las carpetas de tus proyectos

<h5>M贸dulo</h5>
Un m贸dulo es cualquier archivo de Python (o sea que termina con `.py`). Generalmente, contiene c贸digo que puedes reutilizar.

<h5>Paquete</h5>
Una carpeta que contiene m贸dulos. Siempre posee el archivo `__init__.py`. (Se lee dunder init doy py).

| Paquetes |         |
| -------- | ------- |
| M贸dulo  | M贸dulo |
| M贸dulo  | M贸dulo |
| M贸dulo  | M贸dulo |

| exploracion_espacial |                    |
| -------------------- | ------------------ |
| `nave.py`          | `destino.py`     |
| `plataforma.py`    | `lanzamiento.py` |
| `tests.py`         | `validacion.py`  |

Estructura de proyecto:

* README -> Explica c贸mo funciona el proyecto
* .gitignore -> Cosas que no se subir谩n al repo
* venv -> entorno virtual de Python
* exploracion_espacial -> Paquete, dentro de 茅l, los m贸dulos
  * `__init__.py`
  * `nave.py`
  * `destino.py`
  * `plataforma.py`
  * `lanzamiento.py`
  * `tests.py`
  * `validacion.py`

Esta regla no est谩 tallada en piedra. Depende del proyecto y el Framework que uses.

### 驴Qu茅 son los tipados?

 Los tipados es una clasificaci贸n de los lenguajes de programaci贸n, tenemos cuatro tipos:

* Est谩tico
* Din谩mico
* D茅bil
* Fuerte

#### **Est谩tico**

Detectan los errores en tiempo de compilaci贸n. No se ejecuta hasta corregir. Por ej, *Java*

#### **Din谩mico**

Detectan el error en tiempo de ejecuci贸n. Nos dice el error cuando llega a la l铆nea del c贸digo. Por ej, *Python*

#### **Strong**

M谩s severidad con los tipos de datos. Sumar un n煤mero + una letra arrojar谩 error.

#### **Weak**

Menos severidad con los tipos de datos. Si
quiero sumar n煤mero y letra, las concatenar铆a como strings. Castea tipos
de datos autom谩ticamente. Por ej, *PHP, javascript*

### **Tipado est谩tico en Python**

.

Para hacer que Python sea de tipado est谩tico es necesario agregar algo
de sintaxis adicional a lo aprendido, adem谩s, esta caracter铆stica solo
se puede aplicar a partir de la versi贸n 3.6.

```python
# De esta manera se declara una variable, se colocan los dos puntos (:), el tipo de dato y para finalizar se usa el signo igual para asignar el valor a la variable.

<variable> : <tipo_de_dato> = <valor_asignado>

a: int = 5
print(a)

b: str = "Hola"
print(b)

c: bool = True
print(c)
```

Del mismo modo se puede usar esta metodolog铆a de tipado en Python a
funciones adicionando el signo menos a continuaci贸n del signo mayor que
para determinar el tipo de dato. Ejemplo:

```python
def <nombre_func> ( <parametro1> : <tipo_de_dato>, <parametro2> : <tipo_de_dato> ) ->  <tipo_de_dato> :
	pass

def suma(a: int, b: int) -> int :
	return a + b

print(suma(1,2))

# 3
```

Existe una librer铆a de fabrica que viene preinstalada con Python que se llama **typing,** que es de gran utilidad para trabajar con tipado con estructuras de datos entre la versi贸n **3.6** y  **3.9** , entonces:

.

```python
from typing import Dict, List

positives: List [int] = [1,2,3,4,5]

users: Dict [str, int] = {
	"argentina": 1.
	"mexico": 34,
	"colombia": 45,
}

countries: List[Dict[str, str]] = [
	{
		"name" : "Argentina",
		"people" : "45000",
	},
	{
		"name" : "M茅xico",
		"people" : "9000000",
	},
	{
		"name" : "Colombia",
		"people" : "99999999999",
	}
]
```

```python
from typing import Tuple, Dict, List

CoordinatesType = List[Dict[str, Tuple[int, int]]]

coordinates: CoordinatesType = [
	{
		"coord1": (1,2),
		"coord2": (3,5)
	},
	{
		"coord1": (0,1),
		"coord2": (2,5)
	}
]
```

#### Modulo `mypy`

.

El modulo mypy se complementa con el modulo typing ya que permitir谩 mostrar los errores de tipado debil en Python.

### **Scope**

El scope es el alcance que tienen las variables. Depende de donde
declares o inicialices una variable para saber si tienes acceso. **Regla de oro:**

> *una variable solo esta disponible dentro de la region donde fue creada*

#### Local Scope

Es la regi贸n que corresponde el 谩mbito de una funci贸n, donde podremos
tener una o mas variables, las variables van a ser accesibles
煤nicamente en esta region y no ser谩n visibles para otras regiones

#### Global Scope

Al escribir una o mas variables en esta region, estas podr谩n ser accesibles desde cualquier parte del c贸digo.

### Closures

#### **Nested functions** :

Las funciones anidadas son
simplemente funciones creadas dentro de otra funci贸n. Podemos hacer
return de una funci贸n creada dentro de otra funci贸n  y luego guardar
esas funciones en variables que podemos utilizar.

```python
def main():
	a = 1
	def nested():
		print(a)
	return nested

my_func = main()
my_func()
# 1
```

* Eso anterior es un closure く y es b谩sicamente cuando una variable de
  un scope superior es recordada por una funci贸n de scope inferior
  (aunque luego se elimine la de scope superior).
  ```python
  def main():
  	a = 1
  	def nested():
  		print(a)
  	return nested

  my_func = main()
  my_func()
  # 1
  del(main)
  my_func()
  # 1
  ```
* Reglas para encontrar un closure: 
  * Debemos tener una nested function.
  * La nested function debe referenciar un valor de un scope superior.
  * La funci贸n que envuelve a la nested function debe retornarla tambi茅n.
* Ejemplo de closures para crear funciones:
  ```python
  def make_multiplier(x):
  	def multiplier(n):
  		return x*n
  	return multiplier

  times10 = make_multiplier(10)
  times4 = make_multiplier(4)

  print(times10(3)) # 30
  print(times4(5)) #20
  print(times10(times4(2))) # 80
  ```
* Los closure aparecen en dos casos particulares: cuando tenemos una
  clase corta (con un solo m茅todo), los usamos para que sean elegantes. El
  segundo caso, es cuando usamos decoradores



### Decoradores

Un **decorador** es una funci贸n que recibe como
par谩metro otra funci贸n, le a帽ade cosas y retorna una funci贸n diferente.
Tienen la misma estructura que los Closures pero en vez de variables lo
que se env铆a es una funci贸n. Ejemplo:

```python
def decorador(func):
    def envoltura():
        print("Esto se a帽ade a mi funci贸n original.")
        func()
    return envoltura

def saludo():
    print("隆Hola!")

saludo()
# Salida:
# 隆Hola!

saludo = decorador(saludo) # Se guarda la funci贸n decorada en la variable saludo
saludo()                   # La funci贸n saludo est谩 ahora decorada
# Salida:
# Esto se a帽ade a mi funci贸n original.
# 隆Hola!
```

Se puede hacer de manera mas sencilla, con  *az煤car sint谩ctica (sugar syntax)* :
Cuando tenemos un c贸digo que est谩 embellecido para que nosotros lo
veamos de una manera m谩s est谩tica, ayudando a entender de manera mas
sencilla el c贸digo. De esta manera, tenemos el c贸digo anterior:

```python
def decorador(func):
    def envoltura():
        print("Esto se a帽ade a mi funci贸n original.")
        func()
    return envoltura

def saludo():
    print("隆Hola!")
saludo = decorador(saludo) # Se guarda la funci贸n decorada en la variable saludo (se decora)

saludo()                   # La funci贸n saludo est谩 ahora decorada 
```

```python
def decorador(func):
    def envoltura():
        print("Esto se a帽ade a mi funci贸n original.")
        func()
    return envoltura

# De esta manera se decora la funci贸n saludo (equivale a saludo = decorador(saludo) de la 煤ltima l铆nea, quedando ahora en la l铆nea inmediata superior ):
@decorador              
def saludo():
    print("隆Hola!")

saludo()                   # La funci贸n saludo est谩 ahora decorada 
```

Esto permite ahorrar c贸digo al implementar caracter铆sticas (decoradores) comunes a diferentes funciones:

```python
def decorator_upper(func):                  # Funci贸n decoradora
    def wrapper(text):                      # Funci贸n anidada
        return func(text).upper()           # Operaci贸n que realiza el decorado a la funci贸n (func), inserta el texto a la funci贸n original. Convierte todo a may煤sculas.
    return wrapper                          # Devuelve wapper como indica la regla de los Clousures

@decorator_upper                            # Decora la funci贸n message
def message(name):
    return f'{name}, recibiste un mensaje'  # Esto es lo que realiza la funci贸n message, previo a ser decorada.

@decorator_upper                            # Decora la funci贸n warning
def warning(name):
    return f'Usa solo may煤sculas {name}'  # Esto es lo que realiza la funci贸n warning, previo a ser decorada.

print(message("Cesar")) # Output: CESAR, RECIBISTE UN MENSAJE
print(warning("Cesar")) # Output: USA SOLO MAYSCULAS CESAR
```
