## Curso Profesional de python

### Python es un **lenguaje interpretado**

lo que significa que tu c√≥digo es transformado por el int√©rprete (m√°quina virtual de Python) a *bytecode* antes de ser ejecutado por un ordenador con *x* sistema operativo. El *bytecode*es un lenguaje de programaci√≥n de m√°s bajo nivel (si esto no te es claro, te recomiendo que vayas a tomar los cursos sobre [lenguajes y paradigmas de programaci√≥n](https://platzi.com/clases/historia-programacion/) y el de [fundamentos de ing. de software](https://platzi.com/clases/ingenieria/).
(B√°sicamente desde que corres tu programa hasta que la PC lo ejecuta
hay una carrera de relevos de lenguajes o protocolos hasta llegar al
transistor y la se√±al el√©ctrica)

### Garbage collector

Recuerda que el *garbage collector*  toma los objetos y variables que no est√°n en uso y los elimina.

### pycache

_pycache _ es el directorio (carpeta) que contiene el *bytecode* (el c√≥digo intermedio) que crea Python para que lo pueda leer la m√°quina virtual.

Un **m√≥dulo** es cualquier archivo de Python. Generalmente, contiene c√≥digo que puedes reutilizar.

#### C√≥mo organizar las carpetas de tus proyectos

<h5>M√≥dulo</h5>
Un m√≥dulo es cualquier archivo de Python (o sea que termina con `.py`). Generalmente, contiene c√≥digo que puedes reutilizar.

<h5>Paquete</h5>
Una carpeta que contiene m√≥dulos. Siempre posee el archivo `__init__.py`. (Se lee dunder init doy py).

| Paquetes |         |
| -------- | ------- |
| M√≥dulo  | M√≥dulo |
| M√≥dulo  | M√≥dulo |
| M√≥dulo  | M√≥dulo |

| exploracion_espacial |                    |
| -------------------- | ------------------ |
| `nave.py`          | `destino.py`     |
| `plataforma.py`    | `lanzamiento.py` |
| `tests.py`         | `validacion.py`  |

Estructura de proyecto:

* README -> Explica c√≥mo funciona el proyecto
* .gitignore -> Cosas que no se subir√°n al repo
* venv -> entorno virtual de Python
* exploracion_espacial -> Paquete, dentro de √©l, los m√≥dulos
  * `__init__.py`
  * `nave.py`
  * `destino.py`
  * `plataforma.py`
  * `lanzamiento.py`
  * `tests.py`
  * `validacion.py`

Esta regla no est√° tallada en piedra. Depende del proyecto y el Framework que uses.

### ¬øQu√© son los tipados?

üíª Los tipados es una clasificaci√≥n de los lenguajes de programaci√≥n, tenemos cuatro tipos:

* Est√°tico
* Din√°mico
* D√©bil
* Fuerte

#### **Est√°tico**

Detectan los errores en tiempo de compilaci√≥n. No se ejecuta hasta corregir. Por ej, *Java*

#### **Din√°mico**

Detectan el error en tiempo de ejecuci√≥n. Nos dice el error cuando llega a la l√≠nea del c√≥digo. Por ej, *Python*

#### **Strong**

M√°s severidad con los tipos de datos. Sumar un n√∫mero + una letra arrojar√° error.

#### **Weak**

Menos severidad con los tipos de datos. Si
quiero sumar n√∫mero y letra, las concatenar√≠a como strings. Castea tipos
de datos autom√°ticamente. Por ej, *PHP, javascript*

### **Tipado est√°tico en Python**

.

Para hacer que Python sea de tipado est√°tico es necesario agregar algo
de sintaxis adicional a lo aprendido, adem√°s, esta caracter√≠stica solo
se puede aplicar a partir de la versi√≥n 3.6.

```python
# De esta manera se declara una variable, se colocan los dos puntos (:), el tipo de dato y para finalizar se usa el signo igual para asignar el valor a la variable.

<variable> : <tipo_de_dato> = <valor_asignado>

a: int = 5
print(a)

b: str = "Hola"
print(b)

c: bool = True
print(c)
```

Del mismo modo se puede usar esta metodolog√≠a de tipado en Python a
funciones adicionando el signo menos a continuaci√≥n del signo mayor que
para determinar el tipo de dato. Ejemplo:

```python
def <nombre_func> ( <parametro1> : <tipo_de_dato>, <parametro2> : <tipo_de_dato> ) ->  <tipo_de_dato> :
	pass

def suma(a: int, b: int) -> int :
	return a + b

print(suma(1,2))

# 3
```

Existe una librer√≠a de fabrica que viene preinstalada con Python que se llama **typing,** que es de gran utilidad para trabajar con tipado con estructuras de datos entre la versi√≥n **3.6** y  **3.9** , entonces:

.

```python
from typing import Dict, List

positives: List [int] = [1,2,3,4,5]

users: Dict [str, int] = {
	"argentina": 1.
	"mexico": 34,
	"colombia": 45,
}

countries: List[Dict[str, str]] = [
	{
		"name" : "Argentina",
		"people" : "45000",
	},
	{
		"name" : "M√©xico",
		"people" : "9000000",
	},
	{
		"name" : "Colombia",
		"people" : "99999999999",
	}
]
```

```python
from typing import Tuple, Dict, List

CoordinatesType = List[Dict[str, Tuple[int, int]]]

coordinates: CoordinatesType = [
	{
		"coord1": (1,2),
		"coord2": (3,5)
	},
	{
		"coord1": (0,1),
		"coord2": (2,5)
	}
]
```

#### Modulo `mypy`

.

El modulo mypy se complementa con el modulo typing ya que permitir√° mostrar los errores de tipado debil en Python.

### **Scope**

El scope es el alcance que tienen las variables. Depende de donde
declares o inicialices una variable para saber si tienes acceso. **Regla de oro:**

> *una variable solo esta disponible dentro de la region donde fue creada*

#### Local Scope

Es la regi√≥n que corresponde el √°mbito de una funci√≥n, donde podremos
tener una o mas variables, las variables van a ser accesibles
√∫nicamente en esta region y no ser√°n visibles para otras regiones

#### Global Scope

Al escribir una o mas variables en esta region, estas podr√°n ser accesibles desde cualquier parte del c√≥digo.

### Closures

#### **Nested functions** :

Las funciones anidadas son
simplemente funciones creadas dentro de otra funci√≥n. Podemos hacer
return de una funci√≥n creada dentro de otra funci√≥n üòµ y luego guardar
esas funciones en variables que podemos utilizar.

```python
def main():
	a = 1
	def nested():
		print(a)
	return nested

my_func = main()
my_func()
# 1
```

* Eso anterior es un closure ü§Ø y es b√°sicamente cuando una variable de
  un scope superior es recordada por una funci√≥n de scope inferior
  (aunque luego se elimine la de scope superior).
  ```python
  def main():
  	a = 1
  	def nested():
  		print(a)
  	return nested

  my_func = main()
  my_func()
  # 1
  del(main)
  my_func()
  # 1
  ```
* Reglas para encontrar un closure: üî•
  * Debemos tener una nested function.
  * La nested function debe referenciar un valor de un scope superior.
  * La funci√≥n que envuelve a la nested function debe retornarla tambi√©n.
* Ejemplo de closures para crear funciones:
  ```python
  def make_multiplier(x):
  	def multiplier(n):
  		return x*n
  	return multiplier

  times10 = make_multiplier(10)
  times4 = make_multiplier(4)

  print(times10(3)) # 30
  print(times4(5)) #20
  print(times10(times4(2))) # 80
  ```
* Los closure aparecen en dos casos particulares: cuando tenemos una
  clase corta (con un solo m√©todo), los usamos para que sean elegantes. El
  segundo caso, es cuando usamos decoradores

### Decoradores

Un **decorador** es una funci√≥n que recibe como
par√°metro otra funci√≥n, le a√±ade cosas y retorna una funci√≥n diferente.
Tienen la misma estructura que los Closures pero en vez de variables lo
que se env√≠a es una funci√≥n. Ejemplo:

```python
def decorador(func):
    def envoltura():
        print("Esto se a√±ade a mi funci√≥n original.")
        func()
    return envoltura

def saludo():
    print("¬°Hola!")

saludo()
# Salida:
# ¬°Hola!

saludo = decorador(saludo) # Se guarda la funci√≥n decorada en la variable saludo
saludo()                   # La funci√≥n saludo est√° ahora decorada
# Salida:
# Esto se a√±ade a mi funci√≥n original.
# ¬°Hola!
```

Se puede hacer de manera mas sencilla, con  *az√∫car sint√°ctica (sugar syntax)* :
Cuando tenemos un c√≥digo que est√° embellecido para que nosotros lo
veamos de una manera m√°s est√°tica, ayudando a entender de manera mas
sencilla el c√≥digo. De esta manera, tenemos el c√≥digo anterior:

```python
def decorador(func):
    def envoltura():
        print("Esto se a√±ade a mi funci√≥n original.")
        func()
    return envoltura

def saludo():
    print("¬°Hola!")
saludo = decorador(saludo) # Se guarda la funci√≥n decorada en la variable saludo (se decora)

saludo()                   # La funci√≥n saludo est√° ahora decorada 
```

```python
def decorador(func):
    def envoltura():
        print("Esto se a√±ade a mi funci√≥n original.")
        func()
    return envoltura

# De esta manera se decora la funci√≥n saludo (equivale a saludo = decorador(saludo) de la √∫ltima l√≠nea, quedando ahora en la l√≠nea inmediata superior ):
@decorador            
def saludo():
    print("¬°Hola!")

saludo()                   # La funci√≥n saludo est√° ahora decorada 
```

Esto permite ahorrar c√≥digo al implementar caracter√≠sticas (decoradores) comunes a diferentes funciones:

```python

def decorator_upper(func):                  # Funci√≥n decoradora
    def wrapper(text):                      # Funci√≥n anidada
        return func(text).upper()           # Operaci√≥n que realiza el decorado a la funci√≥n (func), inserta el texto a la funci√≥n original. Convierte todo a may√∫sculas.
    return wrapper                          # Devuelve wapper como indica la regla de los Clousures

@decorator_upper                            # Decora la funci√≥n message
def message(name):
    return f'{name}, recibiste un mensaje'  # Esto es lo que realiza la funci√≥n message, previo a ser decorada.

@decorator_upper                            # Decora la funci√≥n warning
def warning(name):
    return f'Usa solo may√∫sculas {name}'  # Esto es lo que realiza la funci√≥n warning, previo a ser decorada.

print(message("Cesar")) # Output: CESAR, RECIBISTE UN MENSAJE
print(warning("Cesar")) # Output: USA SOLO MAY√öSCULAS CESAR
```



### Estructuras de datos avanzadas

#### Iteradores

Antes de entender qu√© son los iteradores, primero debemos entender a los iterables.

Son todos aquellos objetos que podemos recorrer en un ciclo. Son
aquellas estructuras de datos divisibles en elementos √∫nicos que yo
puedo recorrer en un ciclo.

Pero en Python las cosas no son as√≠. Los iterables se convierten en iteradores.

Ejemplo:

```python
# Creando un iterador

my_list = [1,2,3,4,5]
my_iter = iter(my_list)

# Iterando un iterador

print(next(my_iter))

# Cuando no quedan datos, la excepci√≥n StopIteration es elevada
```

---

```python
# Creando un iterador

my_list = [1,2,3,4,5]
my_iter = iter(my_list)

# Iterando un iterador

while True: #ciclo infinito
  try:
    element = next(my_iter)
    print(element)
  except StopIteration:
    break
```

**Momento impactante:** El ciclo ‚Äúfor‚Äù dentro de Python, no existe. Es un while con StopIteration.

```python
my_list = [1,2,3,4,5]

for element in my_list:
  print(element)
```

---

`evenNumbers.py`:

```python
class EvenNumbers:
  """Clase que implementa un iterador de todos los n√∫meros pares,
  o los n√∫meros pares hasta un m√°ximo
  """

  #* Constructor de la clase
  def __init__(self, max = None): #self hace referencia al objeto futuro que voy a crear con esta clase
    self.max = max


  # M√©todo para tener elementos o atributos que voy a necesitar para que el iterador funcione
  def __iter__(self):
    self.num = 0 #Primer n√∫mero par
    #* Convertir un iterable en un iterador
    return self

  # M√©todo para tener la funci√≥n "next" de Python
  def __next__(self):
    if not self.max or self.num <= self.max:
      result = self.num
      self.num += 2
      return result
    else:
      raise StopIteration
```

Ventajas de usar iteradores:

1. Nos ahorra recursos.
2. Ocupan poca memoria.



---

```

```
